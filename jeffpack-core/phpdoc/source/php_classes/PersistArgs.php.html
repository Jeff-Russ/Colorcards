<html>
    <head>
        <script
            type="text/javascript"
            src="../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * PersistArgs is and abstract class to give your class a better way to 
 * parse accept method arguments and persist data between calls to avoid
 * nested callback and reduce the number or required arguments, keeping your code DRY.
 * 
 * @package     JeffPack
 * @subpackage  General PHP Classes
 * @access      public
 * @author      Jeff Russ
 * @copyright   2016 Jeff Russ
 * @license     GPL-2.0
 */
if ( ! class_exists('PersistArgs')) {
	/**
	 * PersistArgs is and abstract class to give your class a better way to 
	 * parse accept method arguments and persist data between calls to avoid
	 * nested callback and reduce the number or required arguments, keeping your code DRY.
	 * 
	 * Most methods are declared protected and meant to be called from an inheriting 
	 * classes methods. 
	 * 
	 * You class's methods would accept &quot;&amp;$args&quot;, either as it's only argument or it's
	 * last argument, acting as a sort of &quot;splat argument&quot; with named parameters. 
	 * 
	 * There will also be a $this-&gt;args array property in your object that mirrors 
	 * the most recently received arguments and any other related data. 
	 * 
	 * The $args sent to a method, if found to be an array, can have it's key/value 
	 * merged into the $this-&gt;args. If it's a single value it's assigned a key. 
	 * Since $args is passed by reference it's updated and syncronized with 
	 * $this-&gt;args meaning caller can use the modified variable in a follow-up
	 * method call to provide a sort of context. If the argument is not supplied, 
	 * values from $this-args is used instead. 
	 */
	abstract class PersistArgs extends HelperModule {

		/** @var array olds whatever variables are needed between calls */
		public $args = array();

		#### Helpers ##############################################################

		/**
		* Get a single value from $args or $this-&gt;args without writing to either.
		* 
		* If $args is an array, the $key is looked up and the value is returned.
		* If $args is a single value, that value is returned. 
		* If $args is null or the key does not exist, $this-&gt;args[$key] is returned
		* without first checking if the key exists. 
		* 
		* An error will be thrown if the $key is not found or therefore this method is 
		* useful if you need to halt things when the value can't be found. 
		*
		* @param  mixed   $args is array or anything else
		* @param  mixed   $key is existing or hypothetical array key
		* @return mixed   $args[$key], $this-&gt;args[$key], or just $args
		* @access protected
		*/
		protected function getArg($args, $key)
		{
			if ( is_array($args) ):
				if ( array_key_exists($key, $args) ):
					return $args[$key];
				// elseif ( array_key_exists($key, $this-&gt;args) ):
				else: # let it get error
					return $this-&gt;args[$key];
				endif;
			elseif ( $args !== null ):
				return $args;
			else:
				// if ( array_key_exists($key, $this-&gt;args) ) 
					# nm, let it error
					return $this-&gt;args[$key];
			endif;
		}

		/**
		* Get a single value from $args only (not checking $this-&gt;args) and without 
		* writing to either.
		* 
		* This method is useful when you create a method which needs a value to be 
		* set in that call without falling back on data from a previous call. 
		* 
		* If $args is an array, the $key is looked up and the value is returned.
		* If $args is a single value, that value is returned. 
		* If $args is null or the key does not exist, null or some other value is 
		* return, which can be set by the optional third argument. 
		*
		* @param  mixed   $args is array or anything else
		* @param  mixed   $key is existing or hypothetical array key
		* @param  mixed   $default (optional) return if value can't be found (defaults to null)
		* @return mixed   $args[$key] or $defaults
		* @access protected
		*/
		protected function getPassedArg($args, $key, $default=null)
		{
			if ( is_array($args) ):
				if ( array_key_exists($key, $args) ):
					return $args[$key];
				else:
					return $default;
				endif;
			elseif ( $args === null ):
				return $default;
			else:
				return $args;
			endif;
		}

		/**
		* This static method is useful for intializing an array from an unknown 
		* variable. It does not modify the object or it's arguments and is use 
		* only for it's return usually to assign to an array variable.  
		* 
		* A new array is returned from the contents of $args which 
		* could be an array itself, a single value or null. The second argument 
		* defines a key to be created if a value not associated with a string 
		* key is found. The return is always an array.
		* 
		* If $args is null an empty array is return and $key is not used.
		* If $args is not an array and not null, that value is added to a new 
		* array at $key and the array is return.
		* If $args is an array lacking $key but has a value at $args[0], 
		* that value is moved to $args[$key] and $args[0] is deleted.
		* If $args is an array but there is no $args[0], it's returned as is. 
		*
		* @param  mixed   $args is array or anything else
		* @param  mixed   $key is a hypothetical array key, usually a string
		* @return array   a new array or a copy of $args if it it an array.
		* @access public
		*/
		static public function toArrayAsKey($args, $key) #PUBLIC!
		{
			if (! is_array($args) ): 
				if ($args !== null):
					$args = array($key =&gt; $args);
				else:
					$args = array();
				endif;
			elseif (array_key_exists(0, $args) &amp;&amp; !array_key_exists($key, $args) ):
				$args[$key] = $args[0];
				unset($args[0]);
			endif;
			return $args;
		}

		/**
		* This method gets a desired value from either the $args parameter or 
		* $this-&gt;args and synchronizes them as a side effect. 
		* 
		* This method modifies both $this-&gt;args and $args to mirror each other
		* and return a desired value from either of them or a default value if 
		* not found (defaults to null). $key must be provided to determine which 
		* element is to be returned
		* 
		* If $args anything not an array but not null, it's assigned to both 
		* $args at $key and returned. 
		* 
		* If $args is an array it's merged in both directions with $this-&gt;args 
		* overriding any matching keys found in $this-&gt;args. If $key is found 
		* in either, it's value is returned, or else $default is returned. 
		* 
		* @param  mixed   $args is array or anything else
		* @param  mixed   $key is a hypothetical array key, usually a string
		* @param  mixed   $default (optional) return if value can't be found (defaults to null)
		* @return mixed   the value finally residing in args[$key] or $default
		* @access protected
		*/
		protected function getArgAndSync(&amp;$args, $key, $default=null)
		{
			if ( is_array($args) ):
				$this-&gt;args = array_merge($this-&gt;args, $args);
			elseif ( $args !== null ):
				$this-&gt;args[$key] = $args;
			endif;
			$args = $this-&gt;args;
			if ( array_key_exists($key, $args) )
				return $args[$key];
			else
				return $default;
		}
		/**
		* This method updates $this-&gt;args from the argument values and returns
		* it even if no change occured. It does not modify either argument so 
		* if you'd like to synchronize them you should use this method's return 
		* to re-assign the local variable(s) you passed in. There are three modes 
		* you can use this method depending on the type and presence of the 
		* second argument. 
		* 
		* SIMPLE MERGE MODE:
		* 
		* If $arg1 or $arg2 is provided as an array and the other is null,
		* it is merged into $this-&gt;args overriding any matching keys in 
		* $this-&gt;args.  
		* 
		* KEY MODE:
		* 
		* When you are uncertain that the first argument is an array you should 
		* provide a key as the second argument which will be used to assign 
		* the value of $arg1 to $this-&gt;args. 
		* 
		* If $arg1 is non-null and not an array it will be added to $this-&gt;args
		* at using $arg2 as a key or or pushed to the end of the $this-&gt;args 
		* at a new int index if $arg2 is not usable as a key.
		* 
		* TWO ARRAY MERGE MODE:
		* 
		* When you are certain $arg1 is either an array or null you can either leave 
		* off the second argument or provide a second array where both will be merged 
		* into $this-args. 
		* 
		* If both arguments are provided and are arrays they are combined,
		* with $arg2 overriding any matching keys in $arg1, then this is merged 
		* into $this-&gt;args overriding any matching keys in $this-&gt;args.  
		* 
		* @param  mixed   $arg1 expected to be array or non-null value
		* @param  mixed   $arg2 expected to be array or key (but optional)
		* @return array   $this-&gt;args
		* @access protected
		*/
		protected function mergeArgs($arg1, $arg2=null) {
			if ( is_array($arg1) )
			{
				if ( is_array($arg2) ) # merge both arrays
					$this-&gt;args = array_merge($this-&gt;args, array_merge($arg1, $arg2) );
				else                   # this ignores arg2
					$this-&gt;args = array_merge($this-&gt;args, $arg1);
			}
			elseif ( $arg1 === null )
			{
				if ( is_array($arg2) ) # merge arg2 to $this and ignore arg1
					$this-&gt;args = array_merge($this-&gt;args, $arg2);
			}
			elseif ( is_int($arg2) || is_string($arg2) )
			{
				# we know $arg1 is a non-null non-array and $arg2 can be a key
				$this-&gt;args[$key] = $arg1;
			}
			else # we know $arg1 is a non-null non-array but $arg2 can't be key
			{
				if ( is_array($arg2) ) $this-&gt;args = array_merge($this-&gt;args, $arg2);
				$this-&gt;args[] = $arg1;
			}
			return $this-&gt;args;
		}
	}
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>